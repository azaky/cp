#include <vector>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <algorithm>
#include <utility>
#include <numeric>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <limits>
using namespace std;

#ifdef DEBUG
	#define debug(...) printf(__VA_ARGS__)
	#define GetTime() fprintf(stderr,"Running time: %.3lf second\n",((double)clock())/CLOCKS_PER_SEC)
#else
	#define debug(...) 
	#define GetTime() 
#endif

//type definitions
typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> vint;

//abbreviations
#define A first
#define B second
#define MP make_pair
#define PB push_back

//macros
#define REP(i,n) for (int i = 0; i < (n); ++i)
#define REPD(i,n) for (int i = (n)-1; 0 <= i; --i)
#define FOR(i,a,b) for (int i = (a); i <= (b); ++i)
#define FORD(i,a,b) for (int i = (a); (b) <= i; --i)
#define FORIT(it,c) for (__typeof ((c).begin()) it = (c).begin(); it != (c).end(); it++)
#define ALL(a) (a).begin(),(a).end()
#define SZ(a) ((int)(a).size())
#define RESET(a,x) memset(a,x,sizeof(a))
#define EXIST(a,s) ((s).find(a) != (s).end())
#define MX(a,b) a = max((a),(b));
#define MN(a,b) a = min((a),(b));

inline void OPEN(const string &s) {
	freopen((s + ".in").c_str(), "r", stdin);
	freopen((s + ".out").c_str(), "w", stdout);
}

/* -------------- end of azaky's template -------------- */

struct ieee {
	vector<vector<bool> > historyB;
	bool B[50];
	char M[256];

	ieee() {
		RESET(B, 0);
		RESET(M, 0);
	}

	void reset() {
		if (historyB.empty()) {
			return;
		}
		historyB.pop_back();
		int x = SZ(historyB) - 1;
		for (int i = 0; i < 5; ++i) {
			if (x < 0) {
				for (int j = 0; j < 10; ++j) {
					B[i * 10 + j] = 0;
				}
			} else {
				for (int j = 0; j < 10; ++j) {
					B[i * 10 + j] = historyB[x][j];
				}
			}
			x--;
		}
	}
	int idxf(vector<bool> I) {
		historyB.PB(I);
		bool x1, x2, x3, x4, x5, x6, x7, x8, x9, y1, y2, y3, y4, y5, y6, y7, y8, y9;
		bool c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c20, c21, c22, c23;
		bool c30, c31, c32, c33, c34, c40, c41, c42, c43, c44, c45;
		bool c51, c52, c53, c54, c55, c61, c62, c63, c64, c65, c73, c74, c75;
		bool c84, c85, c95;
		B[49]=B[39];B[48]=B[38];B[47]=B[37];B[46]=B[36];B[45]=B[35];B[44]=B[34];
		B[43]=B[33];B[42]=B[32];B[41]=B[31];B[40]=B[30];B[39]=B[29];B[38]=B[28];
		B[37]=B[27];B[36]=B[26];B[35]=B[25];B[34]=B[24];B[33]=B[23];B[32]=B[22];
		B[31]=B[21];B[30]=B[20];B[29]=B[19];B[28]=B[18];B[27]=B[17];B[26]=B[16];
		B[25]=B[15];B[24]=B[14];B[23]=B[13];B[22]=B[12];B[21]=B[11];B[20]=B[10];
		B[19]=B[ 9];B[18]=B[ 8];B[17]=B[ 7];B[16]=B[ 6];B[15]=B[ 5];B[14]=B[ 4];
		B[13]=B[ 3];B[12]=B[ 2];B[11]=B[ 1];B[10]=B[ 0];B[ 9]=I[ 9];B[ 8]=I[ 8];
		B[ 7]=I[ 7];B[ 6]=I[ 6];B[ 5]=I[ 5];B[ 4]=I[ 4];B[ 3]=I[ 3];B[ 2]=I[ 2];
		B[ 1]=I[ 1];B[ 0]=I[ 0];
		x1= I[0]|I[1];x2= x1|I[2];x3= x2|I[3];x4= x3|I[4];x5= x4|I[5];x6= x5|I[6];
		x7= x6|I[7];x8= x7|I[8];x9= x8|I[9];
		y1=(!x9)|(I[0]&I[1]);y2=y1|(x1&I[2]);y3=y2|(x2&I[3]);y4=y3|(x3&I[4]);y5=y4|(x4&I[5]);
		y6=y5|(x5&I[6]);y7=y6|(x6&I[7]);y8=y7|(x7&I[8]);y9=y8|(x8&I[9]);
		c0=B[0]|B[10]|B[20]|B[30]|B[40];c1=B[1]|B[11]|B[21]|B[31]|B[41];
		c2=B[2]|B[12]|B[22]|B[32]|B[42];c3=B[3]|B[13]|B[23]|B[33]|B[43];
		c4=B[4]|B[14]|B[24]|B[34]|B[44];c5=B[5]|B[15]|B[25]|B[35]|B[45];
		c6=B[6]|B[16]|B[26]|B[36]|B[46];c7=B[7]|B[17]|B[27]|B[37]|B[47];
		c8=B[8]|B[18]|B[28]|B[38]|B[48];c9=B[9]|B[19]|B[29]|B[39]|B[49];
		c10=!(c0 | c1);
		c11=c0^c1;c12=c0&c1;
		c20=(c10&(!c2));c21=(c10&c2)|(c11&(!c2));c22=(c11&c2)|(c12&(!c2));c23=(c12&c2);
		c30=(c20&(!c3));c31=(c20&c3)|(c21&(!c3));c32=(c21&c3)|(c22&(!c3));
		c33=(c22&c3)|(c23&(!c3));c34=(c23&c3);c40=(c30&(!c4));c41=(c30&c4)|(c31&(!c4));
		c42=(c31&c4)|(c32&(!c4));c43=(c32&c4)|(c33&(!c4));c44=(c33&c4)|(c34&(!c4));
		c45=(c34&c4);c51=(c40&c5)|(c41&(!c5));c52=(c41&c5)|(c42&(!c5));
		c53=(c42&c5)|(c43&(!c5));c54=(c43&c5)|(c44&(!c5));c55=(c44&c5)|(c45&(!c5));
		c62=(c51&c6)|(c52&(!c6));c63=(c52&c6)|(c53&(!c6));c64=(c53&c6)|(c54&(!c6));
		c65=(c54&c6)|(c55&(!c6));c73=(c62&c7)|(c63&(!c7));c74=(c63&c7)|(c64&(!c7));
		c75=(c64&c7)|(c65&(!c7));c84=(c73&c8)|(c74&(!c8));c85=(c74&c8)|(c75&(!c8));
		c95=(c84&c9)|(c85&(!c9));
		bool e=(!c95)|y9;
		bool a[10];
		a[0]=e|((((!c0)&(!c1)&(!c2)&(!c3)&(!c4))|(c0&c1&c2&c3&c4))^c0^c1^c2^c3^c4^(c3&
		(((c0^c8)&c1&c2&c4)^((((c0^c1)&c2&c5)^(c1&c4&c7))&c8))));
		a[1]=e|((((!c0)&(!c1)&(c2)&(!c5)&(c6))|(c0&c1&((!c2)&(!c6))&c5))^c0^c1^c2^c5^c6^(c4&
		((c0&c1&((c2&c3)^(c5&c6)))^(((c1&c7)^(c6&c9))&c3&c8))));
		a[2]=e|((((!c0)&(!c1)&(c3)&(!c5)&(!c7))|(c0&c1&(!c3)&c5&c7))^c0^c1^c3^c5^c7^(c0&c1&c2&
		(c3^c4)&c5)^((c3^c4)&c5&c7&c8&c9));
		a[3]=e|((c3&c5)^(c3&c6)^(c3&c8)^(c3&c9)^(c5&c6)^(c5&c8)^(c5&c9)^(c6&c8)^(c6&c9)^
		(c8|c9)^c3^c5^c6^c8^c9^(c0&c1&c3&c6&c9));
		a[4]=e|((c2&c5)^(c2&c7)^(c2&c8)^(c2&c9)^(c5&c7)^(c5&c8)^(c5&c9)^(c7&c8)^(c7|c9)^
		(c8&c9)^c2^c5^c7^(((c0&c5&c6)^(c1&c3&c4))&c7&c8));
		a[5]=e|((c0&c1)^c0^c2^c4^c6^c7^(c0&c1&c2&c3&c4)^(((c0&((c3&c5)^(c2&c4)))^
		(c1&c4&c6))&c7&c8)^(c3&c4&c6&((c2&c9)^(c5&c7))));
		a[6]=e|(c0^c1^c3^c4^c7^(c0&c1&c2&c4&c9)^(c0&((c1&c4)^(c3&c8))&c5&c7)^
		((((((c0^c1)&c5)^(c0&c4))&c2)^(c1&(c2^c7)&c4))&c6&c8));
		a[7]=e|(c2^c3^c4^(c0&((c2&c3)^((c2^c3)&c7))&c4&c8)^((((c0^c1)&c3&c5)^(((c0^c1)&
		(c4^c5))&c6))&c7&c8));
		int val = 0;
		for (int i = 7; i >= 0; i--) {
			val = val << 1;
			if (a[i]) val = val | 1;
		}
		return val;
	}
	void f(vector<bool> &I) {
		int val = idxf(I);
		M[val] = 1;
	}
	int sum(char *M) {
		int retVal = 0;
		for (int i = 0; i < 256; ++i) {
			retVal += M[i];
		}
		return retVal;
	}
	int main(vector<string> &s) {
		int n = SZ(s);
		vector<bool> I(10);
		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < 10; ++j) {
				I[j] = (s[i][j] & 1) != 0;
			}
			f(I);
		}
		return 1000 * sum(M) - n;
	}
};

///////////////////////////////////////////////////////////

char buffer[100];
string ans[] = {"0001000000","0000000001","0000000100","0000100000","1000000000","0100000000","0000010000","0010000000","0000001000","0001000000","0000100000","1000000000","0000010000","0000000100","0010000000","0001000000","0100000000","0000001000","0000100000","0000010000","1000000000","0100000000","1000000000","0010000000","0000100000","0000001000","0000000010","0000001000","0000100000","0001000000","0100000000","0000000001","0000000010","0010000000","1000000000","0000100000","0100000000","0000010000","0000001000","0000010000","1000000000","0000001000","0010000000","0000000010","0100000000","0000010000","0001000000","1000000000","0000000001","0000000100","0000000010","0000001000","0001000000","1000000000","0100000000","0000000100","0001000000","0000010000","0000010000","0100000000","0010000000","0010000000","0001000000","0010000000","0000100000","0010000000","0000100000","0000001000","0000010000","0010000000","0000001000","0001000000","0000000001","1000000000","0100000000","1000000000","0000001000","0000000001","0010000000","0000000100","0000010000","0100000000","0000100000","0000000001","0000010000","0000001000","0000000100","1000000000","0000000010","0010000000","0100000000","0001000000","0000100000","0000010000","0010000000","0000000100","0000000001","0001000000","0100000000","0000001000","0100000000","0010000000","0000000001","0000100000","0000000010","0001000000","1000000000","0010000000","0000001000","0000000100","0001000000","0000100000","0000010000","1000000000","0010000000","0000000010","0000001000","0000001000","0000001000","1000000000","1000000000","0000000010","0000001000","0000000100","0000000010","0010000000","0001000000","1000000000","0001000000","0000000100","0001000000","1000000000","1000000000","0001000000","0001000000","0000000001","0001000000","0000001000","1000000000","0000100000","1000000000","1000000000","0010000000","0000010000","0000001000","0100000000","0000000001","1000000000","0000100000","0000100000","0000000001","0001000000","0000010000","0000100000","0001000000","0010000000","0000000010","0000010000","0000000100","0100000000","0000001000","0000000001","1000000000","0000000010","0001000000","0000001000","0000010000","0000000100","0000000010","0000000001","0001000000","0000001000","0010000000","0000100000","0010000000","0001000000","0000100000","1000000000","0100000000","0000100000","0000010000","0000001000","0001000000","0010000000","0010000000","0000001000","0000000100","0000001000","0000001000","0000100000","0000000010","0100000000","1000000000","0000000100","0000100000","0001000000","0000000010","0100000000","0001000000","0000100000","0100000000","0100000000","1000000000","0000000010","0000001000","0000010000","0000000001","0100000000","0000000010","0000010000","1000000000","0000000010","0100000000","0000000010","1000000000","0000001000","0000010000","1000000000","0000001000","0010000000","0000000010","0001000000","0000000010","0010000000","0000010000","0000000100","0100000000","0100000000","0000010000","0000000100","1000000000","0010000000","0000100000","0000000001","0000010000","0000000010","0000001000","0010000000","0000100000","0010000000","0000001000","0000000001","0000000010","0100000000","0000000001","0000000010","0000010000","1000000000","0100000000","0000000100","0000000010","0000000010","0000001000","0000000010","0000100000","0001000000","0001000000","0100000000","0000000001","0000010000","0010000000","1000000000","0000000010","0000010000","0000000010","0000001000","0000100000","0000010000","0000010000","0001000000","0000100000","0000100000","0001000000","0000000100","0000000100","0000000010","0000000001","0100000000","0000100000","0000000100","0000001000","0010000000","0000000100","0000000001","1000000000","0100000000","0000001000","0010000000","1000000000","0000100000","0000000010","0000000100","1000000000","0000000010","0001000000","0000000001","0000000001","0000100000","0000000100","1000000000","0000001000","0000000100","0000001000","0001000000","0100000000","0000000010","0000100000","0001000000","0010000000","0000000010","0000000100","0100000000","0000100000","0010000000","0001000000","0000010000","0000000010","0000000010","0000000001","0000100000","1000000000","0000100000","0000000010","0001000000","0001000000","0100000000","0000010000","0000010000","0000100000","0100000000","0000000100","0001000000","0010000000","0000010000","0000100000","0000100000","0010000000","0000100000","0000000001","0001000000","0000010000","0000000001","0000000010","0000001000"};
int n = 344;
int threshold = 253;

int main() {
#if 0
	ieee calc;
	vector<string> s;
	for (int i = 0; i < n; ++i) {
		s.PB(ans[i]);
	}
	printf("%d\n", calc.main(s));
#endif
#if 1
	int bestans = 500;
	while (true) {
		ieee test;
		srand(time(0));
		bool used[256] = {0};
		int cot = 0, xxx = 0;
		vector<string> ans;
		while (cot < threshold) {
			int x = -1;
			int valx = -1;
			for (int i = 1; i <= 1024; i <<= 1) {
				vector<bool> I(10);
				for (int j = 0; j < 10; ++j) {
					I[j] = (i & (1 << j)) != 0;
				}
				int val = test.idxf(I);
				if (used[val]) {
					test.reset();
				} else {
					x = i;
					valx = val;
					used[valx] = 1;
					break;
				}
			}
			if (x == -1) {
				x = 1 << (rand() % 11);
				vector<bool> I(10);
				for (int j = 0; j < 10; ++j) {
					I[j] = (x & (1 << j)) != 0;
				}
				valx = test.idxf(I);
			} else {
				// puts("NEMU COY!");
				cot++;
				// fprintf(stderr, "NEMU COY! count = %d, line = %d\n", cot, xxx);
				// if (cot > 250) {
				// 	vector<int> rest;
				// 	REP(i, 256) {
				// 		if (!used[i]) {
				// 			rest.PB(i);
				// 		}
				// 	}
				// 	fprintf(stderr, "Sisanya:");
				// 	FORIT(it, rest) fprintf(stderr, " %d", *it);
				// 	fprintf(stderr, "\n");
				// }
			}
			{
				string temp = "";
				for (int i = 0; i < 10; ++i) {
					temp += '0' + ((x & (1 << i)) >> i);
				}
				ans.PB(temp);
				// ieee testlagi;
				// fprintf(stderr, "calc = %d\n", testlagi.main(ans));
			}
			xxx++;
			// printf("%4d: %d\n", x, valx);
		}
		if (xxx >= bestans) continue;
		fprintf(stderr, "found = %d\n", xxx);
		bestans = xxx;
		printf("%d\n", xxx);
		printf("string ans[] = {");
		FORIT(it, ans) {
			printf("\"%s\"", it->c_str());
			if (it + 1 == ans.end()) {
				printf("};\n");
			} else {
				printf(",");
			}
		}
		printf("int n = %d;\n", SZ(ans));
		fflush(stdout);
	}
#endif
	// REP(iq, 1000) {
	// 	int i = rand() % 1024;
	// 	vector<bool> I(10);
	// 	for (int j = 0; j < 10; ++j) {
	// 		I[j] = (i & (1 << j)) != 0;
	// 	}
	// 	printf("val[%4d] = %d\n", i, ieee::idxf(I));
	// }

	// scanf("%d", &n);
	// vector<string> s;
	// REP(i, n) {
	// 	scanf("%s", buffer);
	// 	s.PB(buffer);
	// }
	// printf("%d\n", ieee::main(s));
	return 0;
}