/*
ID: a_zaky01
PROG: marathon
LANG: C++
*/

#include <vector>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <algorithm>
#include <utility>
#include <numeric>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <limits>
using namespace std;

#ifdef DEBUG
	#define debug(...) printf(__VA_ARGS__)
	#define GetTime() fprintf(stderr,"Running time: %.3lf second\n",((double)clock())/CLOCKS_PER_SEC)
#else
	#define debug(...) 
	#define GetTime() 
#endif

//type definitions
typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> vint;

//abbreviations
#define A first
#define B second
#define MP make_pair
#define PB push_back

//macros
#define REP(i,n) for (int i = 0; i < (n); ++i)
#define REPD(i,n) for (int i = (n)-1; 0 <= i; --i)
#define FOR(i,a,b) for (int i = (a); i <= (b); ++i)
#define FORD(i,a,b) for (int i = (a); (b) <= i; --i)
#define FORIT(it,c) for (__typeof ((c).begin()) it = (c).begin(); it != (c).end(); it++)
#define ALL(a) (a).begin(),(a).end()
#define SZ(a) ((int)(a).size())
#define RESET(a,x) memset(a,x,sizeof(a))
#define EXIST(a,s) ((s).find(a) != (s).end())
#define MX(a,b) a = max((a),(b));
#define MN(a,b) a = min((a),(b));

inline void OPEN(const string &s) {
	freopen((s + ".in").c_str(), "r", stdin);
	freopen((s + ".out").c_str(), "w", stdout);
}

/* -------------- end of azaky's template -------------- */

#define MAXN 100100
#define INF 1012012012

struct Node {
	int sum, sum1, suma, sumb;
} tree[MAXN << 2];

int n, q, px[MAXN], py[MAXN];

int d(int a, int b) {
	return abs(px[a] - px[b]) + abs(py[a] - py[b]);
}

void build(int v, int l, int r) {
	if (l == r) {
		tree[v].sum = tree[v].sum1 = d(l, l+1);
		tree[v].suma = tree[v].sumb = 0;
	}
	else {
		int vl = v<<1;
		int vr = vl|1;
		int m = (l+r)>>1;
		build(vl, l, m);
		build(vr, m+1, r);
		tree[v].sum = tree[vl].sum + tree[vr].sum;
		tree[v].sum1 = min(min(tree[vl].sum1 + tree[vr].sum, tree[vl].sum + tree[vr].sum1), tree[vl].suma + tree[vr].sumb + d(m, m+2));
		tree[v].suma = tree[vl].sum + tree[vr].suma;
		tree[v].sumb = tree[vl].sumb + tree[vr].sum;
	}
}

void update(int v, int l, int r, int x) {
	if (r < x || x < l) return;
	if (l == r) {
		tree[v].sum = tree[v].sum1 = d(l, l+1);
		tree[v].suma = tree[v].sumb = 0;
	}
	else {
		int vl = v<<1;
		int vr = vl|1;
		int m = (l+r)>>1;
		update(vl, l, m, x);
		update(vr, m+1, r, x);
		tree[v].sum = tree[vl].sum + tree[vr].sum;
		tree[v].sum1 = min(min(tree[vl].sum1 + tree[vr].sum, tree[vl].sum + tree[vr].sum1), tree[vl].suma + tree[vr].sumb + d(m, m+2));
		tree[v].suma = tree[vl].sum + tree[vr].suma;
		tree[v].sumb = tree[vl].sumb + tree[vr].sum;
	}
}

Node query(int v, int l, int r, int i, int j) {
	Node ret;
	if (r < i || j < l) {
		assert(false);
		ret = tree[v];
	}
	else if (i <= l && r <= j) {
		ret = tree[v];
	}
	else {
		int vl = v<<1;
		int vr = vl|1;
		int m = (l+r)>>1;
		if (j <= m) {
			ret = query(vl, l, m, i, j);
		}
		else if (m < i) {
			ret = query(vr, m+1, r, i, j);
		}
		else {
			Node nl = query(vl, l, m, i, j);
			Node nr = query(vr, m+1, r, i, j);
			ret.sum = nl.sum + nr.sum;
			ret.sum1 = min(min(nl.sum1 + nr.sum, nl.sum + nr.sum1), nl.suma + nr.sumb + d(m, m+2));
			ret.suma = nl.sum + nr.suma;
			ret.sumb = nl.sumb + nr.sum;
		}
	}

	// printf("query(%d, [%d..%d], [%d..%d]) = (%d, %d, %d, %d)\n", v, l, r, i, j, ret.sum, ret.sum1, ret.suma, ret.sumb);
	return ret;
}

int main(){
	OPEN("marathon");
	
	scanf("%d%d", &n, &q);
	FOR(i, 1, n) {
		scanf("%d%d", &px[i], &py[i]);
	}

	// build segment tree
	build(1, 1, n-1);

	REP(iq, q) {
		char s[10];
		scanf("%s", s);
		if (s[0] == 'Q') {
			int x, y;
			scanf("%d%d", &x, &y);
			if (x == y) {
				puts("0");
			}
			else {
				Node ans = query(1, 1, n-1, x, y-1);
				printf("%d\n", ans.sum1);
			}
		}
		else {
			int i, x, y;
			scanf("%d%d%d", &i, &x, &y);
			px[i] = x;
			py[i] = y;
			if (i > 1) update(1, 1, n-1, i-1);
			if (i < n) update(1, 1, n-1, i);
		}
	}

	return 0;
}

/* Generated by UsacoTemp v3.0 */
