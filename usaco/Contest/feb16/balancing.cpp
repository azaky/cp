/*
ID: a_zaky01
PROG: balancing
LANG: C++
*/

#include <vector>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <algorithm>
#include <utility>
#include <numeric>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <limits>
using namespace std;

#ifdef DEBUG
	#define debug(...) printf(__VA_ARGS__)
	#define GetTime() fprintf(stderr,"Running time: %.3lf second\n",((double)clock())/CLOCKS_PER_SEC)
#else
	#define debug(...) 
	#define GetTime() 
#endif

//type definitions
typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> vint;

//abbreviations
#define A first
#define B second
#define MP make_pair
#define PB push_back

//macros
#define REP(i,n) for (int i = 0; i < (n); ++i)
#define REPD(i,n) for (int i = (n)-1; 0 <= i; --i)
#define FOR(i,a,b) for (int i = (a); i <= (b); ++i)
#define FORD(i,a,b) for (int i = (a); (b) <= i; --i)
#define FORIT(it,c) for (__typeof ((c).begin()) it = (c).begin(); it != (c).end(); it++)
#define ALL(a) (a).begin(),(a).end()
#define SZ(a) ((int)(a).size())
#define RESET(a,x) memset(a,x,sizeof(a))
#define EXIST(a,s) ((s).find(a) != (s).end())
#define MX(a,b) a = max((a),(b));
#define MN(a,b) a = min((a),(b));

inline void OPEN(const string &s) {
	freopen((s + ".in").c_str(), "r", stdin);
	freopen((s + ".out").c_str(), "w", stdout);
}

/* -------------- end of azaky's template -------------- */

#define MAXN 200100

int n, x[MAXN], y[MAXN];
vector<int> px[MAXN];

vector<int> p[MAXN << 2];

void build(int v, int l, int r) {
	if (l == r) {
		p[v] = px[l];
	} else {
		int vl = v << 1;
		int vr = vl | 1;
		int m = (l + r) >> 1;
		build(vl, l, m);
		build(vr, m + 1, r);
		p[v].resize(SZ(p[vl]) + SZ(p[vr]));
		merge(ALL(p[vl]), ALL(p[vr]), p[v].begin());
	}
}

int query(int v, int l, int r, int xa, int xb, int ya, int yb) {
	int ret = 0;
	// fprintf(stderr, "aquery([%d..%d], [%d..%d], [%d..%d]) = %d\n", l, r, xa, xb, ya, yb, ret);
	if (xa <= l && r <= xb) {
		// fprintf(stderr, "calculating query([%d..%d], [%d..%d], [%d..%d])\n", l, r, xa, xb, ya, yb);
		ret = upper_bound(ALL(p[v]), yb) - lower_bound(ALL(p[v]), ya);
		// fprintf(stderr, "calcualting done\n");
	} else if (r < xa || xb < l) {
		ret = 0;
	} else {
		int vl = v << 1;
		int vr = vl | 1;
		int m = (l + r) >> 1;
		ret = query(vl, l, m, xa, xb, ya, yb) + query(vr, m + 1, r, xa, xb, ya, yb);
	}
	// fprintf(stderr, "query([%d..%d], [%d..%d], [%d..%d]) = %d\n", l, r, xa, xb, ya, yb, ret);
	return ret;
}

int queryBox(int xa, int xb, int ya, int yb) {
	if (xa > xb || ya > yb) {
		return 0;
	}
	int ret = query(1, 1, 1 << 17, xa, xb, ya, yb);
	// if (ret == 0) {
	// 	fprintf(stderr, "queryBox([%d..%d], [%d..%d])\n", xa, xb, ya, yb);
	// }
	return ret;
}

pii getBound(int xl, int xr) {
	int xp = queryBox(xl, xr, 1, 100000);
	if (xp == 0) {
		return MP(1, 1);
	}
	int l = 1, r = 100000;
	while (l + 1 < r) {
		// fprintf(stderr, "[%d..%d]\n", l, r);
		int m = (l + r) / 2;
		int up = queryBox(xl, xr, 1, m);
		int dp = xp - up;
		if (dp < up) {
			r = m;
		} else {
			l = m;
		}
	}
	return MP(l, r);
}

int checkAnswer(int a, int b) {
	// fprintf(stderr, "checkAnswer(%d, %d)\n", a, b);
	// assert(a % 2 == 0 && b % 2 == 0);
	int ul = queryBox(1, a, 1, b);
	int ur = queryBox(a + 1, 100000, 1, b);
	int dl = queryBox(1, a, b + 1, 100000);
	int dr = queryBox(a + 1, 100000, b + 1, 100000);
	int ans = max(max(ul, ur), max(dl, dr));
	// if (ans == 0) {
	// 	fprintf(stderr, "answer(%d, %d) = %d\n", a, b, ans);
	// }
	return ans;
}

void compress(int *x) {
	vector<int> xx;
	REP(i, n) {
		xx.PB(x[i]);
	}
	sort(ALL(xx));
	xx.resize(unique(ALL(xx)) - xx.begin());
	// fprintf(stderr, "xx size = %d\n", SZ(xx));
	map<int, int> idxx;
	int idx = 0;
	FORIT(it, xx) {
		idxx[*it] = ++idx;
	}
	REP(i, n) {
		x[i] = idxx[x[i]];
	}
}

int main(){
	OPEN("balancing");

	scanf("%d", &n);
	REP(i, n) {
		scanf("%d%d", &x[i], &y[i]);
	}

	// bodo amat, grid compress
	compress(x);
	compress(y);

	REP(i, n) {
		px[x[i]].PB(y[i]);
		// fprintf(stderr, "(%d, %d)\n", x[i], y[i]);
	}

	FOR(i, 1, 100000) {
		sort(ALL(px[i]));
	}

	// fprintf(stderr, "huba\n");

	build(1, 1, 1 << 17);

	// fprintf(stderr, "huba\n");

	int ans = n;
	for (int a = 1; a <= 100000; ++a) {
		// on the left
		pii cl = getBound(0, a);
		FOR(i, cl.A, cl.B) {
			if (i & 1) continue;
			MN(ans, checkAnswer(a, i));
		}
		pii cr = getBound(a, 100000);
		FOR(i, cr.A, cr.B) {
			if (i & 1) continue;
			MN(ans, checkAnswer(a, i));
		}
		// if (a % 1000 == 0) {
		// 	fprintf(stderr, "huba %d\n", a);
		// }
	}
	printf("%d\n", ans);
	
	return 0;
}

/* Generated by UsacoTemp v3.0 */
